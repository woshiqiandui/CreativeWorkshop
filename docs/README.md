

   <center><font color='#FF0000'>这</font><font color='#FF7D00'>是</font><font color='#FFFF00'>一</font><font color='#00FF00'>个</font><font color='#0000FF'>神</font>
   <font color='#00FFFF'>奇</font><font color='#FF00FF'>的</font><font color='#FF0000'>网</font><font color='#FF7D00'>站</font></center>
   
 ***



 # 高并发
 
 ## 1.线程和进程

 ### 进程、线程的定义以及区别

  >进程是程序的一次执行过程，是系统运行程序的基本单位。

  >线程与进程相似，但线程是一个比进程更小的执行单位。

  一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的**堆**和**方法区**资源，但每个线程有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为**轻量级进程**。

 ### 线程的生命周期和状态
 Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）：
 ![图片1](img/Java+线程状态变迁.png)
线程的生命周期包含5个阶段，包括：新建、就绪、运行、阻塞、销毁。等待和超时等待严格意义上说不是一种状态。

**新建**：就是刚使用new方法，new出来的线程；

**就绪**：就是调用的线程的start()方法后，这时候线程处于等待CPU分配资源阶段，谁先抢的CPU资源，谁开始执行;

**运行**：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run方法定义了线程的操作和功能;

**阻塞**：在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态，比如sleep()、wait()之后线程就处于了阻塞状态，这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用notify或者notifyAll()方法。唤醒的线程不会立刻执行run方法，它们要再次等待CPU分配资源进入运行状态;

**销毁**：如果线程正常执行完毕后或线程被提前强制性的终止或出现异常导致结束，那么线程就要被销毁，释放资源;

 ### 什么是上下文切换？
 多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是<u>为每个线程分配时间片并轮转</u>的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次**上下文切换**。

概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次**上下文切换**。


 ### 线程死锁以及如何避免
线程死锁是指两个或两个以上的线程互相持有对方所需要的资源，由于synchronized的特性，一个线程持有一个资源，或者说获得一个锁，在该线程释放这个锁之前，其它线程是获取不到这个锁的，而且会一直死等下去，因此这便造成了死锁。

死锁产生的条件：

* 互斥条件：一个资源，或者说一个锁只能被一个线程所占用，当一个线程首先获取到这个锁之后，在该线程释放这个锁之前，其它线程均是无法获取到这个锁的。
* 占有且等待：一个线程已经获取到一个锁，再获取另一个锁的过程中，即使获取不到也不会释放已经获得的锁。
* 不可剥夺条件：任何一个线程都无法强制获取别的线程已经占有的锁
* 循环等待条件：线程A拿着线程B的锁，线程B拿着线程A的锁。
 